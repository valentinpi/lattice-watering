% For help on this document class, see:
% https://ftp.tu-chemnitz.de/pub/tex/macros/latex/contrib/acmart/acmart.pdf
\documentclass[acmtog, language=english, nonacm]{acmart}

\usepackage{cleveref}
\usepackage[T1]{fontenc}
\usepackage{fullpage}
\usepackage[utf8]{inputenc}
\usepackage{siunitx}
\usepackage{tikz}
\usepackage[european]{circuitikz}
\usepackage{titlesec}

\setlength{\headheight}{11.0pt}
\setlength{\parindent}{0pt}

\titleformat{\section}{\normalsize\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalsize\bfseries}{\thesubsubsection}{1em}{}

\title{Software Project Report: \textsc{Lattice Watering}}
\author{Valentin Pickel}
\email{valentinpickel@gmx.de}
\author{Jonas Heinemann}
\author{Christian Müller}
\author{Kaan Dönmez}
\affiliation{%
    \department[0]{Institute for Computer Science}%
    \institution{Freie Universität Berlin}%
    \city{Berlin}%
    \country{Germany}}

\begin{document}
    \maketitle

    \section{Introduction}

    \emph{31st of July 2022} - We may start from scratch by reminiscing the the first meeting of all course participants on April 4th. This software project course should dive into the ecosystem Internet. Before collecting project ideas, a rough split was set between the worlds of the \emph{Internet of Things} (IoT), which deals with low power devices in large networks plagued with packet loss, and the conventional internet and its vastly more potent devices ranging from desktop computers to large-scale servers. Especially, us students should become aware of the aspects that matter when making design decisions with respect to communication solutions. The project \emph{Lattice Watering} eyes out the first of both worlds.

    \subsection{Idea Outline}

    After suggesting the building of an IoT application for watering plants automatically on May 2nd, the software project \emph{Lattice Watering} and its group formed on the 9th of May, comprising of the authors of this report. The term \emph{Lattice} is a reference to the studies of crystal/grid-like molecular structures in physics settings, which are often represented by two-dimensional structures called lattices. The first idea was not just to automate the watering of plants, but also to let the boards drive around on a large grid, hence \emph{Lattice Watering}. As it turned out, the hardware requirements for such a project would be too immense, so after some discussion we stuck to the original idea of an automatic plant watering application, whilst not changing the initial name. The latter decision was made in coordination with the team after some discussion. We thought that the name provides a neat little story for the project.

    In a nutshell, the idea is to be able to use a normal desktop computer to control several smaller microcontrollers that are scattered widely. This may happen in multiple ways. We decided that a user should be able to setup automatic (timed) schedules or humdity thresholds, such that pumps would automatically turn on when the plant is too dry. Both functionalities should be configurable in a web frontend that is designed by us. Besides watering the plants, we also collect statistics like the humidity levels or network usage.

    \subsection{Team Organization and Applied Practices}

    \emph{git} was used as our version control system, with a remote repository setup on \emph{GitHub} with the popular free software license by the \emph{MIT}. Our team members usually did not have fixed tasks, but utilized the agile method of \emph{Kanban}. On GitHub, a Kanban board \cref{fig:kanban_board} was setup, in which members can add new issues and tasks to three categories: \emph{Backlog}, \emph{In Progress} and \emph{Done}. This allowed our work to proceed in an assembly line-type of way, in the sense that there tasks are written down and saved up for when members are idling. However, in the nature of things, some members prefer to work closer to the IoT devices themselves, whilst others work e.g. with the web frontend. This means that tasks like reworking the frontend design are less accessible to backend developers, for instance. It is important to mention that we used \emph{agile} methods, as we all had different experiences in the field of IoT communication we were studying, so agile methods and rapid prototyping seemed like good methods for this project. We did not use a project plan.

    In the repository, we usually worked in several branches and merged branches together when changes were ready to be integrated in other branches. To make the switches between different parts of the codebase easier, we regularly wrote minimal documentations such that we some parts of our codebase are always explained, whilst not investing too much time in the maintenance of small parts. We also tried to perform rationale management by explaining design decisions, which is why we have a small subsection for that inside of the \texttt{README.md} file. The team regularly meet up on Monday to discuss current affairs, in the last two weeks before the presentation on the 18th of July we also performed \emph{integration tests}, meaning that we connected all systems together and overviewed its functionality, especially with several boards \cref{sec:network_structure}.

    We consider it noteworthy that for uniformity in code, we set up some \emph{coding conventions}, which are described in the \texttt{README.md} file. Such include not just whether to use the standardized integer types from \texttt{inttypes.h} in C, but also the use of code formatting tools and static analyzers. Although they are few in this project, we hope that our use of them reflects that we tried take care of code quality at all times, and using matured automatic tools for that eases normally adiministrative tasks. But we also missed out on a few things. Like developing tests and using continuous integration. But at this scale these tools did not seem necessary.
    
    The tools we used further include \texttt{clang-format}, \texttt{just}, \texttt{make}, \texttt{npm}, Visual Studio Code and \texttt{gdb}. Communication was done via the proprietary communication platform \emph{Discord}, which was preferred over a decentralized solution like \emph{Element/Matrix} due to all course members already using it. We may improve on that in a future project.

    \begin{figure}[!hbtp]
        \centering
        \includegraphics[width=\linewidth]{img/kanban_board.png}
        \Description{Figure of Kanban board we used.}
        \caption{The kanban project board. (State: 13th June, 18:32)}
        \label{fig:kanban_board}
    \end{figure}

    \label{sec:hardware} \section{Hardware}

    One major motivation for us was to work close to hardware. The boards and sensory we used came mostly from suggestions by Hauke Petersen, a scientific coworker in the department and lead developer of RIOT OS. In our network \cref{sec:network_structure}, we essentially use three types of devices: A host computer which is quite powerful, a border router that translates traffic of a SixLoWPAN network, that is the name for a set of protocols used in low power radio based communication networks, and so-called nodes. The latter two types of boards use class 2 embedded devices (see RFC 7228) with about 32kB of SRAM memory. A sharp eye may criticize that the border router is also quite a weak board, but during development we tried to mitigate this possible problem by reducing its role in the communication network to a pure routing one. In total, we have the following hardware list:
    \begin{enumerate}
        \item One personal computer with the software set up.
        \item Two SAMR21-XPRO boards, one border router and one node.
        \item Two micro USB cables, optionally a battery connector or powerbank.
        \item One DRV8833 motor driver board.
        \item One electronic pump, see the file mentioned below. It should come with a long tube.
        \item One capacitive moisture sensor, see the file mentioned below.
        \item Nine female jumper cables.
        \item Five male jumper cables.
    \end{enumerate}
    This entire list can be found in \texttt{HWSETUP.md} inside of the repository, with descriptions on how to connect the jumper cables. In the repository, one can also find instructions on how to setup the software. However, we assume that the reader is already familiar with RIOT OS and has the appropriate toolchains and \texttt{udev} rules set up.

    \begin{figure*}[htbp!]
        \centering
        \begin{circuitikz}
            \ctikzset{multipoles/dipchip/width=3}
            \draw (0, 0) node[dipchip, num pins=24, hide numbers, draw only pins={15, 23, 24}, no topmark] (B) {\texttt{SAMR21-XPRO}};
            \draw (B.bpin 24) circle[radius=1.5pt];
            \draw (B.bpin 23) circle[radius=1.5pt];
            \draw (B.bpin 15) circle[radius=1.5pt];
            \node [left] at (B.bpin 24) {\texttt{5V0}};
            \node [left] at (B.bpin 23) {\texttt{GND}};
            \node [left] at (B.bpin 15) {\texttt{PB03}};
            \draw (B.bpin 24) -- +(7, 0) node[above, pos=0.5] {5V};
            \draw ($(B.bpin 24)+(7, 0)$) circle[radius=1.5pt];
            \draw (B.bpin 23) -- +(2, 0);
            \draw ($(B.bpin 24)+(7, -4)$) node[nigfete, bodydiode, tr circle] (mos) {}
                (mos.source) node[anchor=north, below right] {\texttt{S}}
                (mos.gate) node[anchor=east, above left]     {\texttt{G}}
                (mos.drain) node[anchor=south, above right]  {\texttt{D}};
            \draw (mos.source) -- +(0, -2);
            \draw ($(mos.source)+(0, -2)$) -- ($(mos.source)+(-2, -2)$);
            \draw ($(mos.source)+(-2, -2)$) circle[radius=1.5pt];
            \draw (mos.gate) -- +(-1, 0);
            \draw ($(mos.gate)+(-1, 0)$) circle[radius=1.5pt];
            \draw ($(mos.source)+(-2, -2)$) -- ($(mos.source)+(-5, -2)$) -- ($(B.bpin 23)+(2, 0)$);
            \draw ($(mos.gate)+(-3.5, 0)$) to[R=\qty{200}{\ohm}] ($(mos.gate)+(-1, 0)$);
            \draw ($(mos.gate)+(-1, 0)$) to[R=\qty{5}{\kilo\ohm}] ($(mos.source)+(-2, -2)$);
            \draw ($(mos.gate)+(-3.5, 0)$) -- ($(mos.gate)+(-3.5, -0.775)$) -- (B.bpin 15);
            \draw ($(B.bpin 24)+(7, 0)$) -- +(0, -1);
            \draw ($(B.bpin 24)+(7, -1.5)$) circle[radius=0.5];
            \node at ($(B.bpin 24)+(7, -1.5)$) {\texttt{P}};
            \draw ($(B.bpin 24)+(7, -2)$) -- (mos.source);
        \end{circuitikz}
        \Description{Figure of the original circuit idea for the pump.}
        \caption{Original circuit idea for the pump. This is a rough sketch, and does not exactly represent the circuitry involved. \((\texttt{P}, \texttt{S}, \texttt{G}, \texttt{D}) = (\text{Pump}, \text{Source}, \text{Gate}, \text{Drain})\). We credit Hauke Petersen with the design of this circuit.}
        \label{fig:circuit_idea}
    \end{figure*}

    As for the hardware itself, we want to share only one story. There was a very specific problem at the start of the project, which halted development shortly, but we managed to catch up as we were quite early when we tried to obtain hardware. The problem was that when connecting the pump to the node boards themselves, the ones of model \texttt{SAMR21-XPRO}, the pump induces a current of \(\qty{200}{\milli\ampere}\). This is too much for the GPIO pins to handle, as one can read in the manual for the board, which we have provided in the \texttt{man} folder of the repository.

    Together with Hauke, we discussed possible solutions to this problem, of which at first the most promising one can be seen in \cref{fig:circuit_idea}. We can see that in this schematic the pump is connected to the board via the GPIO connection and both the 5 volt and ground pins. We shall not go into the details of the electronics of that circuit and why it would work under ideal conditions. According to Hauke this is rather a matter of experience. What the may note is that the essential idea is that current flows between the \texttt{5V0} and \texttt{GND} pins to drive the pump if and only if as soon as an electric signal on the \texttt{PB03} pin is raised and thus the transistor is switched. We built the circuit, but as it turns out the transistor we had available failed. So Hauke proposed that we obtain some predesigned motor boards, which are documented in \texttt{HWSETUP.md}. Those boards already have this circuit idea embedded in one board, meaning that there are some resistors and a transistor built onto one board and we just have to connecting everything properly.

    \begin{figure}[!hbtp]
        \centering
        \includegraphics[angle=180, width=\linewidth]{img/almost_fully_connected_node.jpg}
        \Description{Picture of an almost fully connected node.}
        \caption{An almost fully connected node. We can see that it is quite a cable salad, in the final presentation we gave we suggested to put everything in a casing so that it looks more compact. On the right we can see the driver board that connects the pump and the board, and on the left the capacitive moisture sensor that one would put into soil to measure humidity. It is not \emph{fully} connected, because for one we would place t he moisture sensor into soil, the pump into water, whilst connecting it with the plastic tube shown on the right, and then we would connect the board to a power source. This could be a battery connector, here the large case on the right that can hold up to four AA batteries, or a simple micro USB cable.}
        \label{fig:almost_fully_connected_node}
    \end{figure}

    To get a feeling for what an almost fully connected node looks like, one may refer to \cref{fig:almost_fully_connected_node}.

    \label{sec:network_structure} \section{Network Structure}

    The structure of our network is illustrated in \cref{fig:network_structure}. In \cref{sec:hardware}, we described that for our devices we had a host, a border router and nodes. We want to precise that a bit.

    The network is divided into two parts. There is the connection between the border router and the host. It is a USB connection in our case, but it uses a technology called \texttt{ethos}, which is a small module/program that RIOT OS developed for setting up Ethernet networks based on serial connections. The user operating the host starts the \texttt{ethos} program on a serial port with the border router and that program sets up a layer 2 connection with the board by binding the port and transfering data inbetween. The physical layer connection is provided by the USB connection. At the same time, the USB port provides the border router with power, so we do not need to connect it to a battery or a plug seperately.

    We have wrapped the \texttt{ethos} program inside of a small \texttt{Makefile} command, which one can inspect in \texttt{br/Makefile}. Besides starting the program, the command also creates a virtual network tap device, which is only natively possible on Linux at this moment. The virtual network device is bounded by \texttt{ethos} and gets assigned the IP \texttt{fc00::}, which is an IPv6 \emph{Unique Local Address} (ULA). With that, we follow the recommended conventions for unique local addresses described in RFC 4193. The border router assigns itself the fixed address \texttt{fc00::1}, such that we may easily debug network issues. So the network prefix \texttt{fc00::/64} at this moment is made up of two devices.

    We introduce the second network. The nodes are designed to be low power devices that can be scattered around a small area such as a small house. They connect themselves to the fixed IP address \texttt{fc00:0:0:1::}, which is the address that we assign the IEEE802154 network interface of our border router. Note that it has such a radio interface for receiving IP packets from the nodes and forwarding them to the frontend. The addresses of the nodes are made up of the prefix \texttt{fc00:0:0:1::/64} and the last 64 bits replaced with the MAC address of the node. So these IP addresses are predetermined. The professor already suggested using an application specific specifier, so this could be an improvement over this rather rough way of designing the layer 3 addressing.

    So we have now described how the devices are setup. But we want to shine a bit more light on the other protocols that are involved in the network. For layer 3, we only use \emph{IPv6} as it is the more modern standard and since RIOT does not support IPv4. We also learned that IPv6 replaces some old technologies such as ARP with new ones such as its very own Neighbor Discovery routines and general layer 2 address resolution techniques.
    
    To perform routing inside of the lossy IoT network, we use the \texttt{Routing Protocol for Low-Power and Lossy Networks} (RPL). RFC 6550 describes it. The short idea is that we may create routing topologies for far areas by designating some network entities as roots such that the nodes can build up graph theoretic tree structures, which are just \emph{Directed Acylic Graphs} (DAGs). The routing now happens in the way that a node has exactly one entity it can route a packet to. Note that the RFC also suggests some useful topologies for these routing schemes, such as a \emph{Destination-Oriented DAG} (DODAG), where there is only one root. This is useful in our case, as it simplifies the routing by quite a lot.

    These three technologies presented two extremes for us during development. For one, setting up \texttt{ethos} and the border router routing table, to route between the IEEE802154 and Ethernet interfaces, yielded unneeded error searches while we were trying to apply the knowledge from the tutorials that were given on the RIOT OS page. The most usual error was that packets just were not routed between the nodes and the host. We checked that by using the ICMP modules from RIOT from shell and sending pings between our fixed IP addresses, see above. Using a snooping tool such as \emph{Wireshark} on the host, we also checked the traffic in hopes of finding out our issues. We cannot replicate all that went wrong during this phase. The professor suggested that we should make proposals on how to improve the RIOT tutorials, but due to stress we have not yet done so. Perhaps the underlying issue also was that the team was just not familiar enough with RIOT and the protocols involved. That is the first extreme: Huge difficulties whilst setting up \texttt{ethos} and IPv6 routing. The second extreme was the very pleasant experience in setting up RPL, which just consisted of designating the border router as a DAG root and then just loading the appropriate modules into both \texttt{br} and \texttt{fw}. The former can be done just using:

    \begin{minipage}{\linewidth}
        \begin{verbatim}
gnrc_rpl_init(netif_ieee802154->pid);
gnrc_rpl_root_init(0, &ieee802154_ip, true, true);
        \end{verbatim}
    \end{minipage}

    The combination of \emph{ethos} and the more-or-less hardcoded network structure was on purpose as it is the most convenient and least complicated way of setting it up. The only thing to keep in mind was to update the firewall rules on our Linux devices, for instance via \texttt{nft}:
    \begin{verbatim}
# nft --handle list ruleset
# sudo nft add rule inet filter input \
           position 9 udp dport 5684 accept
    \end{verbatim}

    \begin{figure*}[!hbtp]
        \centering
        \small
        \begin{tikzpicture}[>=stealth, semithick, scale=0.75]
            \draw[rounded corners=5pt] (-1, -1) rectangle (1, 1);
            \draw[draw=none] (-1, 0) -- (1, 1) node[pos=0.5] {Host/PC};
            \draw (-1, 0) -- (1, 0);
            \draw[draw=none] (-1, 0) -- (1, -1) node[pos=0.5] {\texttt{tap0}};

            \draw[rounded corners=5pt] (-12, -1) rectangle (-5, 1);
            \draw[draw=none] (-12, 0) -- (-5, 1) node[pos=0.5] {Border Router};
            \draw (-12, 0) -- (-5, 0);
            \draw (-8.5, 0) -- (-8.5, -1);
            \draw[draw=none] (-12, 0) -- (-8.5, -1) node[pos=0.5] {\texttt{netif\_ieee802154}};
            \draw[draw=none] (-8.5, 0) -- (-5, -1) node[pos=0.5] {\texttt{netif\_ethernet}};
            \draw[->] (-1, -0.33) -- (-5, -0.33);
            \node[left] at (-1, 0) {\texttt{fc00:0:0:0::}};
            \node[right] at (-5, -1) {\texttt{fc00:0:0:0::1}};
            \node at (-3, 1.5) {\texttt{ethos}};
            \node at (-3, 1) {\texttt{fc00:0:0:0::/64}};
            \draw[->] (-5, -0.66) -- (-1, -0.66);
            \node[below left] at (-12+1.75, -1) {\texttt{fc00:0:0:1::}};

            \newcommand{\networknode}[2]{
                \draw[rounded corners=5pt] (#1, #2) rectangle (#1+3.5, #2-2);
                \draw (#1, #2-1) -- (#1+3.5, #2-1);
                \draw[draw=none] (#1, #2) -- (#1+3.5, #2-1) node[pos=0.5] {\texttt{netif\_ieee802154}};
                \draw[draw=none] (#1, #2-1) -- (#1+3.5, #2-2) node[pos=0.5] {Node};
            }

            \networknode{-12}{-3};
            \networknode{-7}{-3};
            \networknode{-12}{-7};
            \networknode{-7}{-7};
            \networknode{-2}{-7};

            \draw[->] (-12+1.75, -3) -- (-12+1.75, -1);
            \draw[->] (-7+1.75, -3) -- (-12+1.75, -1);
            \draw[->] (-12+1.75, -7) -- (-12+1.75, -5);
            \draw[->] (-7+1.75, -7) -- (-7+1.75, -5);
            \draw[->] (-2+1.75, -7) -- (-7+1.75, -5);

            \node at (0, -2.5) {\texttt{sixlowpan}};
            \node at (0, -3) {\texttt{fc00:0:0:1::/64}};
        \end{tikzpicture}
        \Description{Figure of the network topology. We can see that the border router acts between the host and the SixLoWPAN network.}
        \caption{The Network Topology. The device interfaces are named after our code. The \texttt{tap0} device is named after the typical Linux entry. The network stack is based on COAP, DTLS, UDP, 6LoWPAN IPHC and FRAG, RPL, IPv6. The global IP addresses of the nodes inside the \texttt{fc00:0:0:0:0:0:0:1::/64} network are chosen by appending the layer 2 addresses to the network prefix. The DAG structure of the RPL network is shown schematically.}
        \label{fig:network_structure}
    \end{figure*}

    As for the other protocols used, our communication principle was to design it as energy efficient and with as small and as few regularly sent packets as possible. Thus we ruled out any form of state based communication besides DTLS as we cannot compromise on security: For one, an attacker might be interested in damaging expensive plants to hurt the owner financially and emotionally. Our threat model assumes that no node is compromised, which is why we used Pre-Shared Keys, see \cref{subsec:proxy_and_dtls} for more details.

    So in the standard ISO/OSI model we skip layers five and six, besides what protocol management introduces in form of certain saved cookies by the DTLS protocol, and turn to layers four and seven. The former is not very interesting: We use UDP-based application protocols. For all communication between the nodes and the host, we use non-confirmable CoAP packets that are DTLS encrypted. The exact methods between that can be called using CoAP on the node or on the host are described in the file \texttt{METHODS.md}. Note that since each node uses DTLS with the host, meaning that they both share a secure session, these RPC calls are all secured and unique to one communication. More precisely, in RIOT we use the abstraction GCoAP or GCoAP-DTLS, which allows us to define method listeners directly and send out packages quite easily, whilst possibly introducing a slight bit more of packet duplication, as we do not directly use RIOT OS Packet Buffers. Instead of CoAP, there is also MQTT-SN, a different application-layer protocol. We did not choose it, as for one RIOT does not provide such a good integration with DTLS as with GCoAP, which essentially only requires the developer to register the needed keys, but also one can read in articles that packet loss may be quite huge with MQTT-SN, as \cite{Waehlisch_2021} points out. \cite{Herrero_2020} also gives evidence of CoAP being able to handle traffic floods much better. MQTT-SN might perform slightly better while saving a few bytes, but the difference is not huge. Also, we are much more familiar with the HTTP-like structure of CoAP, so working with it was quite pleasant.

    We note that all of the traffic between the host and the nodes is encoded in the CBOR format, which is a binary, more compact, alternative to JSON.

    The frontend is made up of a Node.JS backend and a small webpage for controlling individual boards. More on that in the next section. We only note that the communication between the Node.JS server and the webpage is based on HTTP and TCP, which is quite usual. Sadly, we still use HTTP 1.1 there, as the Node framework \texttt{express} does not support newer versions, but at least the traffic is \texttt{gzip}-compressed.

    \section{Application Structure}

    \begin{figure*}[!hbtp]
        \centering
        \begin{tikzpicture}[>=stealth, semithick, scale=0.95]
            \small
            \newcommand{\column}[3]{
                \draw[#1] (0, #3) rectangle (6.5, #3-0.5);
                \node[right] at (0, #3-0.25) {#2};
            }
            \column{fill=gray!25}{\textbf{\texttt{plant\_nodes TABLE}}}{0};
            \column{}{\texttt{id INTEGER PRIMARY KEY NOT NULL}}{-0.5};
            \column{}{\texttt{node\_ip TEXT UNIQUE NOT NULL}}{-1};
            \column{}{\texttt{pump\_activated INTEGER}}{-1.5};
            \column{}{\texttt{dry\_value INTEGER}}{-2};
            \column{}{\texttt{wet\_value INTEGER}}{-2.5};
            \column{}{\texttt{watering\_threshold\_bottom INTEGER}}{-3};
            \column{}{\texttt{watering\_threshold\_target INTEGER}}{-3.5};
            \column{}{\texttt{watering\_threshold\_timeout INTEGER}}{-4};
            \renewcommand{\column}[3]{
                \draw[#1] (8, #3) rectangle (16.5, #3-0.5);
                \node[right] at (8, #3-0.25) {#2};
            }
            \column{fill=gray!25}{\textbf{\texttt{plant\_humidities TABLE}}}{0};
            \column{}{\texttt{id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL}}{-0.5};
            \column{}{\texttt{node INTEGER NOT NULL}}{-1};
            \column{}{\texttt{date\_time INTEGER}}{-1.5};
            \column{}{\texttt{humidity INTEGER}}{-2};
            \column{}{\texttt{FOREIGN KEY (node) REFERENCES plant\_nodes(id)}}{-2.5};
            \renewcommand{\column}[3]{
                \draw[#1] (8, #3-3.5) rectangle (16.5, #3-4);
                \node[right] at (8, #3-3.75) {#2};
            }
            \column{fill=gray!25}{\textbf{\texttt{plant\_watering\_schedules TABLE}}}{0};
            \column{}{\texttt{id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL}}{-0.5};
            \column{}{\texttt{node INTEGER NOT NULL}}{-1};
            \column{}{\texttt{watering\_begin INTEGER}}{-1.5};
            \column{}{\texttt{watering\_end INTEGER}}{-2};
            \column{}{\texttt{FOREIGN KEY (node) REFERENCES plant\_nodes(id)}}{-2.5};
            \draw (6.5, -0.75) -- (8, -1.25);
            \draw (6.5, -0.75) -- (8, -4.75);
            \node[above right] at (6.5, -0.75) {1};
            \node[below left] at (8, -1.25) {\(n\)};
        \end{tikzpicture}
        \Description{Figure of our database schema. It shows all three tables. - One for storing general node information, one for humiditiy values and one for the watering schedules.}
        \caption{The SQLite database schema. The upper left table persists some of the current configurations and the current status for each node. The network structure guarantees the uniqueness of the IPs, so it suffices to use them as an identifier in our use case. One may consider replacing this with an application-specific ID as we have described above, which may for one have to persist on the nodes themselves, e.g. via EEPROM. One can find this exact structure in \texttt{front/db.js}. The other two tables store the humidity values over time of the plants such that we can access them later on, and the current fixed-time watering schedules. Remember that we offer threshold-based and schedule-based watering.}
        \label{fig:db_scheme}
    \end{figure*}

    In total, we have developed \emph{five} different applications which all work together.
    \begin{itemize}
        \item \texttt{fw}: The firmware that is deployed on the nodes themselves reads out sensor values and sends them the host.
        \item \texttt{br}: The border router acts as a mediator between the lossy SixLoWPAN and the local Ethos network with the host. It allows the nodes that are reachable to send messages to the host computer.
        \item \texttt{proxy}: The proxy receives DTLS traffic from the nodes, decrypts them, appends a target IP and forwards them to the backend software written in Node.JS.
        \item \texttt{front}: The backend software serves the webpage for the frontend and manages the database.
        \item \texttt{www}: The website written in JavaScript, which may or may not be considered a seperate application, offers the user
    \end{itemize}

    The frontend also stores the humidity data and the current status of nodes according to the data regularly transmitted on the \texttt{/data} route. \cref{fig:db_scheme} shows the database scheme. We use SQLite, a very small and fast single user database, which suffices for our usecase. For something larger we may need multiple users and thus a different database, which should not be too difficult given the complexity of our current database operations.

    \subsection{Embedded Work: \texttt{br} and \texttt{fw}}

    Both firmwares are kept very simple. Both are based on RIOT OS with its default GNRC protocol stack. We considered using other stacks such as OpenWSN and OpenThread, but GNRC was preferred due to its simplicity and its prevalence in RIOTs examples.

    The \texttt{br} firmware sets up a small border router as a RPL root, with a route between the \texttt{sixlowpan} and \texttt{ethos} networks and with a watchdog. It also responds to ICMP packets for pings. The \texttt{fw} firmware is slightly more complicated in that it also sets up some sensory, GCoAP routes and DTLS encryption. For the evaluation of the firmwares we refer to the very last section.

    \label{subsec:proxy_and_dtls} \subsection{\texttt{proxy} and DTLS}

    The \texttt{Datagram Transport Layer Security} protocol aims to introduce security of communication to the unsecured UDP protocol. DTLS (RFC 4347) behaves similiar to TLS in that before a communication may take place, a participant first has to negotiate secure ciphers for communication, but not in that the packets are assured to arrive in the correct order or fully. However, the protocol guarantees this for the transmitted payload data.

    To enable DTLS for our application, we had to first include the \texttt{gcoap\_dtls} package in our \texttt{fw} in RIOT with a \emph{Pseudo Random Number Generator} (PRNG) and an appropriate library, in our case \texttt{tinydtls}. We did not use WolfSSL as it is currently not supported by the \texttt{gcoap} RIOT abstraction for CoAP.
    
    Sadly introducing DTLS to our communication turned out to give us some of the worst trouble we had in the project, because Node.JS support for DTLS is in quite a rough state as this time, as none of the libraries we were trying out worked with. Note that there is an official issue for introducing DTLS to Node, but the developers there are not very active at the moment: \cite{node-dtls-issue}. And it is not clear if this will be resolved anytime soon, as the new protocol QUIC emerged. To be precise, we tried the following libraries:

    \begin{itemize}
        \item \texttt{dtls} \cite{npm-dtls}: This NPM package just does not contain anything. 
        \item \texttt{openssl-dtls} \cite{npm-openssl-dtls}: Node FFI bindings that work, but during development, OpenSSL did not work with the ciphersuite \texttt{TLS\_PSK\_WITH\_AES\_128\_CCM\_8}, which is used by \texttt{tinydtls}. The cipher negotiation fails for to us unknown reasons.
        \item \texttt{node-mbed-dtls} \cite{npm-node-mbed-dtls}: Based on \texttt{mbed-dtls}, but with the same issue as with \texttt{openssl-dtls}.
        \item \texttt{werift-dtls} \cite{npm-werift-dtls}: Crashes upon receival of a Client Hello packet, also very poorly documented code. As it seems, it is part of a bigger set of tools for WebRTC.
        \item \texttt{nodejs-dtls} \cite{npm-nodejs-dtls}: Only contains a DTLS client.
        \item \texttt{@nodertc/dtls} \cite{npm-nodertc-dtls}: Only contains a DTLS client. Development for a server seems to be ongoing on the \texttt{main} branch on GitHub, but with no recent activity
        \item \texttt{node-dtls-proxy} \cite{npm-node-dtls-proxy}: Crashes upon receival of a Client Hello packet.
        \item \texttt{goldy} \cite{github-goldy}: Cipher negotiation with a node fails, also it seems that the proxy only forwards traffic between two peers, but we want to be dynamic in that multiple nodes can connect to the server and we do not need to start a proxy for each one seperately.
    \end{itemize}

    There was also a short unsuccessful attempt at writing a very small proxy using python-dtls, but this was conceptually flawed, as the proxy needs to know where to route the packets from the frontend. In the end, as the board uses \texttt{tinydtls}, we decided to use Rust to write a small proxy using \texttt{tinydtls-sys}. \cref{fig:dtls_proxy} shows the structure of the proxy, which acts in the middle of the communication between the frontend and the nodes. Note that the proxy is running on the host computer. We chose Rust as the developer that assigned himself this task wanted to get to practice it more, and it seemed to be a suitable language due to Rust safety guarantees. Although one may argue that Rust is more difficult to learn, but the proxy complexity is not that high. Because Rust bindings exist for RIOT, we could also have developed the firmwares in Rust, but not every team member is familiar with the language and we did not have that much time.

    \begin{figure}[!hbtp]
        \centering
        \begin{tikzpicture}[>=stealth, semithick, scale=0.45]
            \tiny
            \draw (0, 0) rectangle (2, -2) node[pos=0.5] {\texttt{node}};
            \draw[draw=gray!75] (4, 0) rectangle (4+2, -2) node[pos=0.5] {\textcolor{gray!75}{\texttt{br}}};
            \draw (7, 1) rectangle (8+9, -3) node[pos=0.5] {};
            \draw (9, 0) rectangle (9+2.5, -2) node[align=center, pos=0.5, text width=2cm] {
                \texttt{proxy}\\
                \texttt{sessions[i]}
            };
            \draw (14, 0) rectangle (14+2, -2) node[pos=0.5] {\texttt{front}};
            \draw (2, -0.5) -- (9, -0.5);
            \node[above right] at (2, -0.5) {\texttt{5684}};
            \node[above left] at (9, -0.5) {\texttt{5684}};
            \draw (2, -1.5) -- (9, -1.5);
            \node[below right] at (2, -1.5) {\texttt{5684}};
            \node[below left] at (9, -1.5) {\texttt{5684}};
            \node[above right] at (11.5, -0.5) {\texttt{5686}};
            \node[below right] at (11.5, -1.5) {\texttt{5685}};
            \node[above left] at (14, -0.5) {\texttt{5683}};
            \node[below left] at (14, -1.5) {\texttt{5683}};
            \draw[dashed] (11.5, -0.5) -- (14, -0.5);
            \draw[dashed] (11.5, -1.5) -- (14, -1.5);
        \end{tikzpicture}
        \Description{Figure of the DTLS proxy. It shows how the proxy takes DTLS traffic from nodes, translates them to general CoAP and forwards them to the host.}
        \caption{The DTLS proxy. Secure channels are represented by thick lines, insecure channels by thin lines. We have denoted the UDP ports. The \texttt{br} is greyed out as it only routes the packets. Note that each node has its own DTLS session registered in the proxy, the index \texttt{i} is for illustration. There can be at most 16 as of writing. Also the \texttt{proxy} has two sockets for communication with the backend, simply due to constraints with the C FFI in Rust which we were not able to fix by this time.}
        \label{fig:dtls_proxy}
    \end{figure}

    When a board wants to send data through the \texttt{/data} CoAP POST method of the host, it first tries to establish a secure DTLS session. For that, it sends a Client Hello packet and then does cipher negotation such that the future communication partners know how to encrypt and decrypt packages. One special property of our communication is that we use \emph{Pre-Shared Keys} (PSKs). Via an \emph{identity message}, the server tells the node which pre-shared key to use. We only have one, so we called our identity \texttt{default}. The PSKs themselves are just random data, here 16 bytes, as RIOT does not support longer keys. We automatically generate them using a script, and recommend that inside of \texttt{README.md}.

    \subsection{For the Browser: \texttt{front} and \texttt{www}}

    A small backend using \texttt{Node.JS} and a website were developed. The backend operates a database with \texttt{SQLite} to store all data received and the corresponding IPv6-Addresses. The methods the backend offers are only documented in code, but not in a seperate file, as these are internal functionalities. It will register newly connected IPv6-Addresses if not already present as nodes in the plant\_nodes table and its current humidity and time value in the plant\_humidities table. The frontend will show all registered nodes in an overview depicting their current humidity and IPv6-Addresses. This could be changed to show only nodes registered in the last \texttt{X}-minutes to portray only active and currently used plant nodes. All database accesses are done by the backend and only the backend which will send the information to the frontend if requested. We used async functions whenever a database request was issued since \texttt{Javascript} would not wait for the query to finish and use a \texttt{null} as the output. Async functions allowed us to make promises to only continue working after the query has been finished. 

    The backend uses packages such as \texttt{coap} and \texttt{express} to establish the communication to the node and to the website served. \texttt{chartjs} is used to generate a static image which is served to the frontend. The frontend to backend communication is done by HTML GET and POST requests. After every function call we send status 204 back to the frontend which stops the browser from loading a different or current site.
    
    The websites HTML and CSS were written manually. We use small HTML templates that are inserted using DOM operations for dynamic behavior and \texttt{Javascript} to issue database requests and the current time.

    \section{Evaluation and Closing Words}

    We shall give some thoughts about the final result of the project and some highly non-scientific evaluation results.

    \subsection{Discussion on Production-Readiness Marketability}

    As explained in the section on hardware, the node devices that are arguably the most important parts of the system as they themselves water the plants and take measurements are quite unorganized. For a product look, one needs to consider putting each node in a case and fastening the connections, possibly by soldering more of the cables. Especially during the final weeks we had boards failing to connect the pump due to loose contacts over the jumper cables.

    Regarding production-readiness, the product needs much more testing, especially in automation. Whilst we claim to have developed some measures for implementation robustness, we do not claim a very good correctness. An Over-The-Air update system has also not been developed, although as the professor has pointed out, this is quite an open problem in IoT.

    \subsubsection{Software Robustness}

    Our implementation has a few properties that make it a bit more robust in terms of security and scalability:
    \begin{itemize}
        \item Only a certain amount of devices can open up a session with the DTLS proxy. A malicious client is simply blocked if there are too many nodes are registered.
        \item We have taken care of minimizing packet size as much as possible. The average packet in the \texttt{sixlowpan} network is about 116 bytes large \cref{subsubsec:network_statistics}.
        \item A watchdog is running on each node, restarting the node when it does not get updated after a while. This even helped us during debugging, when strange bugs lead to the board freezing. The main reason for deploying a watchdog is simply the scenario when a plant is being watered and the watchdog freezes for some reason. It needs to be restarted then.
        \item When the frontend loads data for visualization, it does not load \emph{all} data from \texttt{plant\_humidities}, but only a certain amount. This could be improved even further by only loading the very last datum upon startup.
    \end{itemize}

    \label{subsubsec:network_statistics} \subsubsection{Network Statistics}

    Please note that we do not claim full correctness or reproducibility for the following statistics. They are non-scientific and should just reflect our experience with the devices.

    Leaving a system of one node, a border router and a host running for about an hour, calibrating the sensory once and toggling the pump twice, we collected the following data: The node transferred 92537 bytes in 795 unicast packets and 71 packets with no failures, whilst receiving 14886 bytes in 192 packets.

    Surely more devices could lead to much more packets being exchanged, for instance due to IPv6 neighbor advertisements or discovery and due to RPL routing activities. We also had no transfer failure, which is highly unlikely when the distances get larger and the network thus becomes lossier.

    \subsubsection{Energy Statistics}

    Please note our starting words in \cref{subsubsec:network_statistics}.

    Letting a single node run on a battery connector with four AA batteries yields a lifetime of about five days. There are several factors that influence this result, such as, again, more devices in the network and their induced routing activity; but also the interval of sending data might be too high, the fact deep sleep functionalities were not used, the PRNG used might be too much of a computational load, the watering frequency as the pump consumes a lot of power and others. Strategies for improving the battery life also consist of rechargable, batteries or even solar panels as the plants need light anyways.

    \subsection{Reflection on our Deployed Practices}

    Development was not always easy, as during early phases we often got stuck with the hardware and RIOT. One remarkable difficulty was in setting up the humidity sensor. As we did not find a good way of interpreting the digital values coming from the analog connection with the sensor and it needing to apparently connect to the wrong pin, - See \texttt{HWSETUP.md}: Its VCC port must be connected to ID for some reason. - we even had to transfer this task over to the user, which is quite unsatisfying. Communication problems like merges that break certain branches of our repository did not make our lives easier. During the last two weeks of development quite a lot was not ready in the frontend, like the scheduling functionality, but we caught up on that.

    \subsection{Possible Future Enhancements}

    We list a few possible enhancements in the code.
    \begin{itemize}
        \item Port \texttt{br} and \texttt{fw} over to Rust.
        \item Either one figures out what the problem with the strange fluctuations of the capacitive sensor are, or one switches it out for a more reliable one.
        \item Let the proxy use a more secure RNG for \texttt{tinydtls} than the default implementation.
        \item The frontend should be ported to TypeScript.
        \item The website looks a bit outdated, one should revisit its design.
    \end{itemize}

    \subsection{Conclusion}

    We explored a small part of the world of RIOT OS when discovering its network stack and also learned about the difficulty of making several softwares and their developments working together. The final product, by our very non-scientific tests, seems to possess some desirable qualities such as being secure, fast, bandwidth-saving and energy-efficient. As for the functionality of the system itself, we may remind us that sadly the thresholding mechanism for watering still does not work fluently, but the scheduling mechanism does. It has been tested several times. Coupling that with properties such as the automatic registration of new devices and the collection of statistics whilst possessing very slowly increasing storage requirements, we may note that the system is working quite well and provides one possible way of watering ones plants.

    \bibliographystyle{acm}
    \bibliography{report}

    %\listoffigures
\end{document}