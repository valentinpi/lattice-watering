% For help on this document class, see:
% https://ftp.tu-chemnitz.de/pub/tex/macros/latex/contrib/acmart/acmart.pdf
\documentclass[acmtog, language=english, nonacm]{acmart}

\usepackage[T1]{fontenc}
\usepackage{fullpage}
\usepackage[utf8]{inputenc}
\usepackage{siunitx}
\usepackage{tikz}
\usepackage[european]{circuitikz}
\usepackage{titlesec}

\setlength{\headheight}{11.0pt}
\setlength{\parindent}{0pt}

\titleformat{\section}{\normalsize\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalsize\bfseries}{\thesubsubsection}{1em}{}

\title{Software Project Report: \textsc{Lattice Watering}}
\author{Valentin Pickel}
\email{valentinpickel@gmx.de}
\author{Jonas Heinemann}
\author{Christian Müller}
\author{Kaan Dönmez}
\affiliation{%
    \department[0]{Institute for Computer Science}%
    \institution{Freie Universität Berlin}%
    \city{Berlin}%
    \country{Germany}}


\begin{document}
    \maketitle

    \section{Introduction}

    We may start from scratch by reminiscing the the first meeting of all course participants on April 4th. This software project course should dive into the ecosystem internet. To do so, a rough split was set between the worlds of the \emph{Internet of Things} (IoT), which deals with low power devices in large networks plagued with packet loss, and the conventional internet and its vastly more potent desktop computers and servers. Especially, us students should become aware of design decisions with respect to the communication solutions that our software should utilize. The project \emph{Lattice Watering} eyes out the first of both worlds.

    \subsection{Idea Outline}

    After suggesting the building an IoT application for watering plants automatically on May 2nd, the software project \emph{Lattice Watering} and its group formed on the 9th of May, comprising of the aforementioned members. The term \emph{Lattice} is a reference to the studies of crystal/grid-like molecular structures in physics settings, which are often represented by two-dimensional structures called lattices. The first idea was not just to automate the watering of the plants, but also to let the boards drive around on a large grid. As it turns out, the hardware requirements for such a project would be too difficult to implement, so after some discussion we stuck to the original idea of a plant watering application, not changing the initial name.

    In a nutshell, the idea is to be able to use a normal desktop computer to control several smaller microcontrollers, that are scattered widely. This may happen by setting automatic rules, or by the microcontrollers automatically turning on the water pumps as soon as humidity levels, which are measured by sensory, drop beyond a certain threshold. The latter aspect can be configured in a web frontend that is designed by us. Besides watering the plants, we also collect statistics like the humidity levels or network usage.

    \subsection{Team Organization and Applied Practices}

    For a detailled overview of the code hierarchy, one can look into the file \texttt{README.md} inside of the project directory.
    
    \emph{git} was used as our version control system, with a repository setup on \emph{GitHub}. Our team members usually did not have fixed tasks, but utilize the agile method of \emph{Kanban}. On GitHub, a kanban board was setup, in which members can add new issues and tasks to three categories: \emph{Backlog}, \emph{In Progress} and \emph{Done}. This allowed our work to proceed in a assembly line-type way, in the sense that there are certain tasks that are saved up for later. However, in the nature of things, some members prefer to work closer to the IoT devices themselves, whilst others work e.g. with the web frontend. It is important to mention that we used \emph{agile} methods, as we all had different experiences in the field of IoT communication we were studying, so agile methods and rapid prototyping seemed like good methods for this project.

    Our methods of work also include \emph{code conventions}, which are described in the \texttt{README.md} file. Such include using formatting tools and static analyzers, as well as code practices. Although they are quite few in this project, they reflect that we should take care of code quality at all times, and using matured automatic tools for that eases a normally adiministrative task.

    Communication was done via the proprietary communication platform \emph{Discord}, which was preferred over a decentralized solution like \emph{Element/Matrix} due to all course members already using it.

    \begin{figure*}[!hbtp]
        \centering
        \includegraphics[width=\linewidth]{img/kanban_board.png}
        \Description{Figure of Kanban board we used.}
        \caption{The kanban project board. (State: 13th June, 18:32)}
    \end{figure*}

    \section{Hardware}

    \begin{figure*}[htbp!]
        \centering
        \begin{circuitikz}
            \ctikzset{multipoles/dipchip/width=3}
            \draw (0, 0) node[dipchip, num pins=24, hide numbers, draw only pins={15, 23, 24}, no topmark] (B) {\texttt{SAMR21-XPRO}};
            \draw (B.bpin 24) circle[radius=1.5pt];
            \draw (B.bpin 23) circle[radius=1.5pt];
            \draw (B.bpin 15) circle[radius=1.5pt];
            \node [left] at (B.bpin 24) {\texttt{5V0}};
            \node [left] at (B.bpin 23) {\texttt{GND}};
            \node [left] at (B.bpin 15) {\texttt{PB03}};
            \draw (B.bpin 24) -- +(7, 0) node[above, pos=0.5] {5V};
            \draw ($(B.bpin 24)+(7, 0)$) circle[radius=1.5pt];
            \draw (B.bpin 23) -- +(2, 0);
            \draw ($(B.bpin 24)+(7, -4)$) node[nigfete, bodydiode, tr circle] (mos) {}
                (mos.source) node[anchor=north, below right] {\texttt{S}}
                (mos.gate) node[anchor=east, above left]     {\texttt{G}}
                (mos.drain) node[anchor=south, above right]  {\texttt{D}};
            \draw (mos.source) -- +(0, -2);
            \draw ($(mos.source)+(0, -2)$) -- ($(mos.source)+(-2, -2)$);
            \draw ($(mos.source)+(-2, -2)$) circle[radius=1.5pt];
            \draw (mos.gate) -- +(-1, 0);
            \draw ($(mos.gate)+(-1, 0)$) circle[radius=1.5pt];
            \draw ($(mos.source)+(-2, -2)$) -- ($(mos.source)+(-5, -2)$) -- ($(B.bpin 23)+(2, 0)$);
            \draw ($(mos.gate)+(-3.5, 0)$) to[R=\qty{200}{\ohm}] ($(mos.gate)+(-1, 0)$);
            \draw ($(mos.gate)+(-1, 0)$) to[R=\qty{5}{\kilo\ohm}] ($(mos.source)+(-2, -2)$);
            \draw ($(mos.gate)+(-3.5, 0)$) -- ($(mos.gate)+(-3.5, -0.775)$) -- (B.bpin 15);
            \draw ($(B.bpin 24)+(7, 0)$) -- +(0, -1);
            \draw ($(B.bpin 24)+(7, -1.5)$) circle[radius=0.5];
            \node at ($(B.bpin 24)+(7, -1.5)$) {\texttt{P}};
            \draw ($(B.bpin 24)+(7, -2)$) -- (mos.source);
        \end{circuitikz}
        \Description{Figure of the original circuit idea for the pump.}
        \caption{Original circuit idea for the pump. This is a rough sketch, and does not exactly represent the circuitry involved. \((\texttt{P}, \texttt{S}, \texttt{G}, \texttt{D}) = (\text{Pump}, \text{Source}, \text{Gate}, \text{Drain})\). We credit Hauke Petersen with the design of this circuit.}
    \end{figure*}

    We shall not go into the details of the electronics of that circuit and why it would work under ideal conditions. We built the circuit, but as it turns out the transistor we had available failed. So we obtained some predesigned motor boards.

    \section{Network Structure}

    \begin{figure*}[!hbtp]
        \centering
        \begin{tikzpicture}[>=stealth, semithick]
            \draw[rounded corners=5pt] (-1, -1) rectangle (1, 1);
            \draw[draw=none] (-1, 0) -- (1, 1) node[pos=0.5] {Host/PC};
            \draw (-1, 0) -- (1, 0);
            \draw[draw=none] (-1, 0) -- (1, -1) node[pos=0.5] {\texttt{tap0}};

            \draw[rounded corners=5pt] (-12, -1) rectangle (-5, 1);
            \draw[draw=none] (-12, 0) -- (-5, 1) node[pos=0.5] {Border Router};
            \draw (-12, 0) -- (-5, 0);
            \draw (-8.5, 0) -- (-8.5, -1);
            \draw[draw=none] (-12, 0) -- (-8.5, -1) node[pos=0.5] {\texttt{netif\_ieee802154}};
            \draw[draw=none] (-8.5, 0) -- (-5, -1) node[pos=0.5] {\texttt{netif\_ethernet}};
            \draw[->] (-1, -0.33) -- (-5, -0.33);
            \node[left] at (-1, 0) {\texttt{fc00:0:0:0::}};
            \node[right] at (-5, -1) {\texttt{fc00:0:0:0::1}};
            \node at (-3, 1.5) {\texttt{ethos}};
            \node at (-3, 1) {\texttt{fc00:0:0:0::/64}};
            \draw[->] (-5, -0.66) -- (-1, -0.66);
            \node[below left] at (-12+1.75, -1) {\texttt{fc00:0:0:1::}};

            \newcommand{\networknode}[2]{
                \draw[rounded corners=5pt] (#1, #2) rectangle (#1+3.5, #2-2);
                \draw (#1, #2-1) -- (#1+3.5, #2-1);
                \draw[draw=none] (#1, #2) -- (#1+3.5, #2-1) node[pos=0.5] {\texttt{netif\_ieee802154}};
                \draw[draw=none] (#1, #2-1) -- (#1+3.5, #2-2) node[pos=0.5] {Node};
            }

            \networknode{-12}{-3};
            \networknode{-7}{-3};
            \networknode{-12}{-7};
            \networknode{-7}{-7};
            \networknode{-2}{-7};

            \draw[->] (-12+1.75, -3) -- (-12+1.75, -1);
            \draw[->] (-7+1.75, -3) -- (-12+1.75, -1);
            \draw[->] (-12+1.75, -7) -- (-12+1.75, -5);
            \draw[->] (-7+1.75, -7) -- (-7+1.75, -5);
            \draw[->] (-2+1.75, -7) -- (-7+1.75, -5);

            \node at (0, -2.5) {\texttt{sixlowpan}};
            \node at (0, -3) {\texttt{fc00:0:0:1::/64}};
        \end{tikzpicture}
        \Description{Figure of the network topology. We can see that the border router acts between the host and the SixLoWPAN network.}
        \caption{The Network Topology. The device interfaces are named after our code. The \texttt{tap0} device is named after the typical Linux entry. The network stack is based on COAP, DTLS, UDP, 6LoWPAN IPHC and FRAG, RPL, IPv6. The global IP addresses of the nodes inside the \texttt{fc00:0:0:0:0:0:0:1::/64} network are chosen by appending the Layer 2 addresses to the network prefix. The DAG structure of the RPL network is shown schematically.}
    \end{figure*}

    \section{Application Structure}

    \begin{figure*}[!hbtp]
        \centering
        \begin{tikzpicture}[>=stealth, semithick, scale=0.95]
            \draw (0, 0) rectangle (2, -2) node[pos=0.5] {\texttt{node}};
            \draw[draw=gray!75] (4, 0) rectangle (4+2, -2) node[pos=0.5] {\textcolor{gray!75}{\texttt{br}}};
            \draw (7, 1) rectangle (8+9, -3) node[pos=0.5] {};
            \draw (9, 0) rectangle (9+2.5, -2) node[align=center, pos=0.5, text width=2cm] {
                \texttt{proxy}\\
                \texttt{sessions[i]}
            };
            \draw (14, 0) rectangle (14+2, -2) node[pos=0.5] {\texttt{front}};
            \draw (2, -0.5) -- (9, -0.5);
            \node[above right] at (2, -0.5) {\texttt{5684}};
            \node[above left] at (9, -0.5) {\texttt{5684}};
            \draw (2, -1.5) -- (9, -1.5);
            \node[below right] at (2, -1.5) {\texttt{5684}};
            \node[below left] at (9, -1.5) {\texttt{5684}};
            \node[above right] at (11.5, -0.5) {\texttt{5686}};
            \node[below right] at (11.5, -1.5) {\texttt{5685}};
            \node[above left] at (14, -0.5) {\texttt{5683}};
            \node[below left] at (14, -1.5) {\texttt{5683}};
            \draw[dashed] (11.5, -0.5) -- (14, -0.5);
            \draw[dashed] (11.5, -1.5) -- (14, -1.5);
        \end{tikzpicture}
        \Description{Figure of the DTLS proxy. It shows how the proxy takes DTLS traffic from nodes, translates them to general CoAP and forwards them to the host.}
        \caption{The DTLS proxy. Secure channels are represented by thick lines, insecure channels by thin lines. We have denoted the UDP ports. The \texttt{br} is greyed out as it only routes the packets. Note that each node has its own DTLS session registered in the proxy, the index \texttt{i} is for illustration. There can be at most 16 as of writing. Also the \texttt{proxy} has two sockets for communication with the backend, simply due to constraints with the C FFI in Rust which we were not able to fix by this time.}
    \end{figure*}

    \begin{figure*}[!hbtp]
        \centering
        \begin{tikzpicture}[>=stealth, semithick, scale=0.95]
            \small
            \newcommand{\column}[3]{
                \draw[#1] (0, #3) rectangle (6.5, #3-0.5);
                \node[right] at (0, #3-0.25) {#2};
            }
            \column{fill=gray!25}{\textbf{\texttt{plant\_nodes TABLE}}}{0};
            \column{}{\texttt{id INTEGER PRIMARY KEY NOT NULL}}{-0.5};
            \column{}{\texttt{node\_ip TEXT UNIQUE NOT NULL}}{-1};
            \column{}{\texttt{pump\_activated INTEGER}}{-1.5};
            \column{}{\texttt{dry\_value INTEGER}}{-2};
            \column{}{\texttt{wet\_value INTEGER}}{-2.5};
            \column{}{\texttt{watering\_threshold\_bottom INTEGER}}{-3};
            \column{}{\texttt{watering\_threshold\_target INTEGER}}{-3.5};
            \column{}{\texttt{watering\_threshold\_timeout INTEGER}}{-4};
            \renewcommand{\column}[3]{
                \draw[#1] (8, #3) rectangle (16.5, #3-0.5);
                \node[right] at (8, #3-0.25) {#2};
            }
            \column{fill=gray!25}{\textbf{\texttt{plant\_humidities TABLE}}}{0};
            \column{}{\texttt{id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL}}{-0.5};
            \column{}{\texttt{node INTEGER NOT NULL}}{-1};
            \column{}{\texttt{date\_time INTEGER}}{-1.5};
            \column{}{\texttt{humidity INTEGER}}{-2};
            \column{}{\texttt{FOREIGN KEY (node) REFERENCES plant\_nodes(id)}}{-2.5};
            \renewcommand{\column}[3]{
                \draw[#1] (8, #3-3.5) rectangle (16.5, #3-4);
                \node[right] at (8, #3-3.75) {#2};
            }
            \column{fill=gray!25}{\textbf{\texttt{plant\_watering\_schedules TABLE}}}{0};
            \column{}{\texttt{id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL}}{-0.5};
            \column{}{\texttt{node INTEGER NOT NULL}}{-1};
            \column{}{\texttt{watering\_begin INTEGER}}{-1.5};
            \column{}{\texttt{watering\_end INTEGER}}{-2};
            \column{}{\texttt{FOREIGN KEY (node) REFERENCES plant\_nodes(id)}}{-2.5};
            \draw (6.5, -0.75) -- (8, -1.25);
            \draw (6.5, -0.75) -- (8, -4.75);
            \node[above right] at (6.5, -0.75) {1};
            \node[below left] at (8, -1.25) {\(n\)};
        \end{tikzpicture}
        \Description{Figure of our database schema. It shows all three tables. - One for storing general node information, one for humiditiy values and one for the watering schedules.}
        \caption{The SQLite database schema. The left table persists the current configurations for each node. The network structure guarantees the uniqueness of the IPs, so it suffices to use them as an identifier in our use case. One may consider replacing this with an application-specific ID which would have to persist on the nodes themselves, e.g. via EEPROM. One can find this exact structure in \texttt{front/db.js}.}
    \end{figure*}

    In total, we have developed \emph{five} different applications which all work together.
    \begin{itemize}
        \item \texttt{fw}: The firmware that is deployed on the nodes themselves reads out sensor values and sends them the host.
        \item \texttt{br}: The border router acts as a mediator between the lossy SixLoWPAN and the local Ethos network with the host. It allows the nodes that are reachable to send messages to the host computer.
        \item \texttt{proxy}: The proxy receives DTLS traffic from the nodes, decrypts them, appends a target IP and forwards them to the backend software written in Node.JS.
        \item \texttt{front}: The backend software serves the webpage for the frontend and manages the database.
        \item \texttt{www}: The website written in JavaScript, which may or may not be considered a seperate application, offers the user
    \end{itemize}

    To enable DTLS for our application, we had to first include the \texttt{gcoap\_dtls} package in RIOT with a PRNG (Pseudo Random Number Generator) and an appropriate library, in this case \texttt{tinydtls}. However, Node.JS support for DTLS is in quite a rough state as this time, as none of the libraries we were trying out worked with. To be precise, we tried the following libraries:

    - dtls -> Das hattest du inkludiert, aber darin ist gar nix drinnen. S. https://www.npmjs.com/package/dtls
- openssl-dtls https://www.npmjs.com/package/openssl-dtls
- node-mbed-dtls https://www.npmjs.com/package/node-mbed-dtls
- werift-dtls -> Eventuell funktioniert das jetzt, ich sollte das nochmal anschauen https://www.npmjs.com/package/werift-dtls
- nodejs-dtls -> Enthält nur einen Client. https://www.npmjs.com/package/nodejs-dtls
- @nodertc/dtls -> Enthält nur einen Client. https://www.npmjs.com/package/@nodertc/dtls

    - node-dtls-proxy https://www.npmjs.com/package/node-dtls-proxy
- goldy https://github.com/ibm-security-innovation/goldy

    There was also a short unsuccessful attempt at writing a very small proxy using python-dtls, but this was conceptually flawed, as the proxy needs to know where to route the packets from the frontend. In the end, as the board uses \texttt{tinydtls}, we decided to use Rust to write a small proxy using \texttt{tinydtls-sys}.

    \section{Closing Words}

    %\listoffigures
\end{document}
