\contentsline {figure}{\numberline {1}{\ignorespaces The kanban project board. (State: 13th June, 18:32)}}{2}{}%
\contentsline {figure}{\numberline {2}{\ignorespaces Circuit for the pump P.}}{2}{}%
\contentsline {figure}{\numberline {3}{\ignorespaces The Network Topology. The device interfaces are named after our code. The \texttt {tap0} device is named after the typical Linux entry. The network stack is based on COAP, DTLS, UDP, 6LoWPAN IPHC and FRAG, RPL, IPv6. The global IP addresses of the nodes inside the \texttt {fc00:0:0:0:0:0:0:1::/64} network are chosen by appending the Layer 2 addresses to the network prefix. The DAG structure of the RPL network is shown schematically.}}{3}{}%
\contentsline {figure}{\numberline {4}{\ignorespaces The DTLS proxy. Secure channels are represented by thick lines, insecure channels by thin lines. We have denoted the UDP ports. The \texttt {br} is greyed out as it only routes the packets. Note that each node has its own DTLS session registered in the proxy, the index \texttt {i} is for illustration. There can be at most 16 as of writing. Also the \texttt {proxy} has two sockets for communication with the backend, simply due to constraints with the C FFI in Rust which we were not able to fix by this time.}}{4}{}%
\contentsline {figure}{\numberline {5}{\ignorespaces The SQLite database schema. The left table persists the current configurations for each node. The network structure guarantees the uniqueness of the IPs, so it suffices to use them as an identifier in our use case. One may consider replacing this with an application-specific ID which would have to persist on the nodes themselves, e.g. via EEPROM. One can find this exact structure in \texttt {front/db.js}.}}{4}{}%
